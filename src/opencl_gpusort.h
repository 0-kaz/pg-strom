/*
 * opencl_gpupreagg.h
 *
 * Preprocess of aggregate using GPU acceleration, to reduce number of
 * rows to be processed by CPU; including the Sort reduction.
 * --
 * Copyright 2011-2014 (C) KaiGai Kohei <kaigai@kaigai.gr.jp>
 * Copyright 2014 (C) The PG-Strom Development Team
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
#ifndef OPENCL_GPUSORT_H
#define OPENCL_GPUSORT_H

/*
 * GPU Accelerated Sorting
 *
 * It packs kern_parambu, status field, and kern_row_map structure
 * within a continuous memory area, to translate this chunk with
 * a single DMA call.
 *
 * +----------------+  -----
 * | status         |    ^
 * +----------------+    |
 * | __padding__    |    |
 * +----------------+    |
 * | kern_parambuf  |    |
 * | +--------------+    |
 * | | length   o--------------+
 * | +--------------+    |     | kern_row_map is located just after
 * | | nparams      |    |     | the kern_parambuf (because of DMA
 * | +--------------+    |     | optimization), so head address of
 * | | poffset[0]   |    |     | kern_gpuscan + parambuf.length
 * | | poffset[1]   |    |     | points kern_row_map.
 * | |    :         |    |     |
 * | | poffset[M-1] |    |     |
 * | +--------------+    |     |
 * | | variable     |    |     |
 * | | length field |    |     |
 * | | for Param /  |    |     |
 * | | Const values |    |     |
 * | |     :        |    |     |
 * +-+--------------+ <--------+
 * | kern_row_map   |    |
 * | +--------------+    |
 * | | nvalids (=N) |    | 'nvalids' is the length of kern_row_map.
 * | +--------------+    | It is the minimum 2^N value that is larger than
 * | | rindex[0]    |    | or equal to kds->nitems.
 * | | rindex[1]    |    |
 * | |    :         |    |
 * | | rindex[N]    |    V
 * +-+--------------+  -----
 */
typedef struct
{
	cl_int			status;
	cl_char			__padding__[4];
	kern_parambuf	kparams;
	/* kern_row_map shall be located next to the kparams */
} kern_gpusort;

#define KERN_GPUSORT_PARAMBUF(kgsort)				\
	((__global kern_parambuf *)(&(kgsort)->kparams)
#define KERN_GPUSORT_PARAMBUF_LENGTH(kgsort)		\
	(KERN_GPUSORT_PARAMBUF(kgsort)->length)
#define KERN_GPUSORT_KROWMAP(kgsort)				\
	((__global kern_row_map *)						\
	 ((__global char *)(kgsort) +					\
	  STROMALIGN(offsetof(kern_gpusort, kparams) +	\
				 KERN_GPUSORT_PARAMBUF_LENGTH(kgsort))))
#define KERN_GPUSORT_BUFFER_SIZE(kgsort, nitems)

#define KERN_GPUSORT_DMASEND_OFFSET(kgsort)			0
#define KERN_GPUSORT_DMASEND_LENGTH(kgsort)			\
	((uintptr_t)(KERN_GPUSORT_KROWMAP(kgsort)->rindex) -	\
	 (uintptr_t)(kgsort))
#define KERN_GPUSORT_DMARECV_OFFSET(kgsort)			0
#define KERN_GPUSORT_DMARECV_LENGTH(kgsort)					\
	((uintptr_t)(KERN_GPUSORT_KROWMAP(kgsort)->rindex +		\
				 KERN_GPUSORT_KROWMAP(kgsort)->nvalids) -	\
	 (uintptr_t)(kgsort))

#ifdef	/* OPENCL_DEVICE_CODE */
/*
 * Sorting key comparison function - to be generated by PG-Strom
 * on the fly.
 */
static cl_int gpusort_keycomp(__private cl_int *errcode,
							  __global kern_data_store *kds,
							  __global kern_data_store *ktoast,
							  size_t x_index,
							  size_t y_index);
/*
 * gpusort_preparation - fill up krowmap->rindex array.
 */
__kernel void
gpusort_preparation(__global kern_gpusort *kgsort)
{
	__global kern_row_map  *krowmap = KERN_GPUSORT_KROWMAP(kgsort);
	size_t		nvalids = krowmap->nvalids;
	size_t		index;

	/* put initial value of rindex */
	for (index = get_global_id(0);
		 index < nvalids;
		 index += get_global_size(0))
		krowmap->rindex[index] = index;
}

/*
 * gpusort_bitonic_local
 *
 * It tries to apply each steps of bitonic-sorting until its unitsize
 * reaches the workgroup-size (that is expected to power of 2).
 */
__kernel void
gpusort_bitonic_local(__global kern_gpusort *kgsort,
					  __global kern_data_store *kds,
					  __global kern_data_store *ktoast,
					  KERN_DYNAMIC_LOCAL_WORKMEM_ARG)
{
	cl_int		errcode = StromError_Success;



out:
	kern_writeback_error_status(&kgsort->status, errcode, LOCAL_WORKMEM);
}

/*
 * gpusort_bitonic_step
 *
 * It tries to apply individual steps of bitonic-sorting for each step,
 * but does not have restriction of workgroup size. The host code has to
 * control synchronization of each step not to overrun.
 */
__kernel void
gpusort_bitonic_step(__global kern_gpusort *kgsort,
					 cl_int bitonic_unitsz,
					 __global kern_data_store *kds,
					 __global kern_data_store *ktoast,
					 KERN_DYNAMIC_LOCAL_WORKMEM_ARG)
{
	cl_int		errcode = StromError_Success;
	cl_bool		reversing = (bitonic_unitsz < 0 ? true : false);
	size_t		unitsz = (bitonic_unitsz < 0
						  ? -bitonic_unitsz
						  : bitonic_unitsz);


out:
	kern_writeback_error_status(&kgsort->status, errcode, LOCAL_WORKMEM);
}

/*
 * gpusort_bitonic_merge
 *
 * It handles the merging step of bitonic-sorting if unitsize becomes less
 * than or equal to the workgroup size.
 */
__kernel void
gpusort_bitonic_merge(__global kern_gpupreagg *kgpreagg,
					  __global kern_data_store *kds,
					  __global kern_data_store *ktoast,
					  KERN_DYNAMIC_LOCAL_WORKMEM_ARG)
{
	cl_int		errcode = StromError_Success;



out:
	kern_writeback_error_status(&kgsort->status, errcode, LOCAL_WORKMEM);
}

#else
/* Host side representation of kern_gpusort. It performs as a message
 * object of PG-Strom, has a key of OpenCL device program, a file mapped
 * data-store (because it tends to consume massive RAM) and kern_row_map
 * that is expected to store the index of records.
 */
typedef struct
{
	pgstrom_message		msg;
	Datum				dprog_key;
	pgstrom_data_store *pds;	/* source data store (file mapped row-store) */
	kern_gpusort		kern;
} pgstrom_gpusort;

#endif	/* OPENCL_DEVICE_CODE */
#endif	/* OPENCL_GPUSORT_H */
