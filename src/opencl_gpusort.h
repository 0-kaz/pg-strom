/*
 * opencl_gpupreagg.h
 *
 * Preprocess of aggregate using GPU acceleration, to reduce number of
 * rows to be processed by CPU; including the Sort reduction.
 * --
 * Copyright 2011-2014 (C) KaiGai Kohei <kaigai@kaigai.gr.jp>
 * Copyright 2014 (C) The PG-Strom Development Team
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
#ifndef OPENCL_GPUSORT_H
#define OPENCL_GPUSORT_H

/*
 * GPU Accelerated Sorting
 *
 * It packs kern_parambu, status field, and kern_row_map structure
 * within a continuous memory area, to translate this chunk with
 * a single DMA call.
 *
 * +----------------+
 * | kern_parambuf  |
 * | +--------------+
 * | | length   o---------+
 * | +--------------+     | kern_row_map is located just after
 * | | nparams      |     | the kern_parambuf (because of DMA
 * | +--------------+     | optimization), so head address of
 * | | poffset[0]   |     | kern_gpuscan + parambuf.length
 * | | poffset[1]   |     | points kern_row_map.
 * | |    :         |     |
 * | | poffset[M-1] |     |
 * | +--------------+     |
 * | | variable     |     |
 * | | length field |     |
 * | | for Param /  |     |
 * | | Const values |     |
 * | |     :        |     |
 * +-+--------------+ <---+
 * | kern_resultbuf |
 * | +--------------+
 * | | nrels (=2)   |
 * | +--------------+
 * | | nrooms       |
 * | +--------------+
 * | | nitems       |
 * | +--------------+
 * | | errcode      |
 * | +--------------+
 * | | has_rechecks |
 * | +--------------+
 * | | all_visible  |
 * | +--------------+
 * | | __padding__[]|
 * | +--------------+
 * | | results[0]   | A pair of results identify the records being sorted.
 * | | results[1]   | result[even number] indicates chunk_id.
 * | +--------------+   (It is always same in a single kernel execution)
 * | | results[2]   | result[odd number] indicated item_id; that is index
 * | | results[3]   |   of a row within a sorting chunk
 * | +--------------+
 * | |     :        |
 * +-+--------------+  -----
 */
typedef struct
{
	kern_parambuf	kparams;
	/* kern_resultbuf (nrels = 2) shall be located next to the kparams */
} kern_gpusort;

#define KERN_GPUSORT_PARAMBUF(kgsort)				\
	((__global kern_parambuf *)(&(kgsort)->kparams)
#define KERN_GPUSORT_PARAMBUF_LENGTH(kgsort)		\
	(KERN_GPUSORT_PARAMBUF(kgsort)->length)
#define KERN_GPUSORT_RESULTBUF(kgsort)			\
	((__global kern_resultbuf *)				\
	 ((__global char *)&(kgsort)->kparams +		\
	  STROMALIGN((kgsort)->kparams.length)))
#define KERN_GPUSORT_RESULTBUF_LENGTH(kgsort)			\
	STROMALIGN(offsetof(kern_resultbuf,					\
		results[KERN_GPUSORT_RESULTBUF(kgsort)->nrels *	\
				KERN_GPUSORT_RESULTBUF(kgsort)->nrooms]))
#define KERN_GPUSORT_LENGTH(kgsort)				\
	(offsetof(kern_gpusort, kparams) +			\
	 KERN_GPUSORT_PARAMBUF_LENGTH(kgsort) +		\
	 KERN_GPUSORT_RESULTBUF_LENGTH(kgsort))
#define KERN_GPUSORT_DMASEND_OFFSET(kgsort)		\
	offsetof(kern_gpusort, kparams)
#define KERN_GPUSORT_DMASEND_LENGTH(kgsort)			\
	(KERN_GPUSORT_LENGTH(kgsort) -					\
	 offsetof(kern_gpusort, kparams))
#define KERN_GPUSORT_DMARECV_OFFSET(kgsort)			\
	((uintptr_t)KERN_GPUSORT_RESULTBUF(kgsort) -	\
	 (uintptr_t)(kgsort))
#define KERN_GPUSORT_DMARECV_LENGTH(kgsort)			\
	KERN_GPUSORT_RESULTBUF_LENGTH(kgsort)

#ifdef	/* OPENCL_DEVICE_CODE */
/*
 * Sorting key comparison function - to be generated by PG-Strom
 * on the fly.
 */
static cl_int gpusort_keycomp(__private cl_int *errcode,
							  __global kern_data_store *kds,
							  __global kern_data_store *ktoast,
							  size_t x_index,
							  size_t y_index);
/*
 * gpusort_preparation - fill up krowmap->rindex array.
 */
__kernel void
gpusort_preparation(__global kern_gpusort *kgsort)
{
	__global kern_row_map  *krowmap = KERN_GPUSORT_KROWMAP(kgsort);
	size_t		nvalids = krowmap->nvalids;
	size_t		index;

	/* put initial value of rindex */
	for (index = get_global_id(0);
		 index < nvalids;
		 index += get_global_size(0))
		krowmap->rindex[index] = index;
}

/*
 * gpusort_bitonic_local
 *
 * It tries to apply each steps of bitonic-sorting until its unitsize
 * reaches the workgroup-size (that is expected to power of 2).
 */
__kernel void
gpusort_bitonic_local(__global kern_gpusort *kgsort,
					  __global kern_data_store *kds,
					  __global kern_data_store *ktoast,
					  KERN_DYNAMIC_LOCAL_WORKMEM_ARG)
{
	cl_int		errcode = StromError_Success;



out:
	kern_writeback_error_status(&kgsort->status, errcode, LOCAL_WORKMEM);
}

/*
 * gpusort_bitonic_step
 *
 * It tries to apply individual steps of bitonic-sorting for each step,
 * but does not have restriction of workgroup size. The host code has to
 * control synchronization of each step not to overrun.
 */
__kernel void
gpusort_bitonic_step(__global kern_gpusort *kgsort,
					 cl_int bitonic_unitsz,
					 __global kern_data_store *kds,
					 __global kern_data_store *ktoast,
					 KERN_DYNAMIC_LOCAL_WORKMEM_ARG)
{
	cl_int		errcode = StromError_Success;
	cl_bool		reversing = (bitonic_unitsz < 0 ? true : false);
	size_t		unitsz = (bitonic_unitsz < 0
						  ? -bitonic_unitsz
						  : bitonic_unitsz);


out:
	kern_writeback_error_status(&kgsort->status, errcode, LOCAL_WORKMEM);
}

/*
 * gpusort_bitonic_merge
 *
 * It handles the merging step of bitonic-sorting if unitsize becomes less
 * than or equal to the workgroup size.
 */
__kernel void
gpusort_bitonic_merge(__global kern_gpupreagg *kgpreagg,
					  __global kern_data_store *kds,
					  __global kern_data_store *ktoast,
					  KERN_DYNAMIC_LOCAL_WORKMEM_ARG)
{
	cl_int		errcode = StromError_Success;



out:
	kern_writeback_error_status(&kgsort->status, errcode, LOCAL_WORKMEM);
}

#else
/* Host side representation of kern_gpusort. It performs as a message
 * object of PG-Strom, has a key of OpenCL device program, a file mapped
 * data-store (because it tends to consume massive RAM) and kern_row_map
 * that is expected to store the index of records.
 */
typedef struct
{
	pgstrom_message		msg;
	Datum				dprog_key;
	cl_int				chunk_id;
	pgstrom_data_store *pds;	/* source data store (file mapped row-store) */
	kern_gpusort		kern;
} pgstrom_gpusort;

#endif	/* OPENCL_DEVICE_CODE */
#endif	/* OPENCL_GPUSORT_H */
