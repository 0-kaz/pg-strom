/*
 * cuda_postgis.cu
 *
 * Routines of basic PostGIS functions & operators for CUDA GPU devices
 * --
 * Copyright 2011-2020 (C) KaiGai Kohei <kaigai@kaigai.gr.jp>
 * Copyright 2014-2020 (C) The PG-Strom Development Team
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
#include "cuda_common.h"
#include "cuda_postgis.h"

/* ================================================================
 *
 * Internal Utility Routines
 *
 * ================================================================ */
STATIC_INLINE(const void *)
__getPointPtr(cl_uint flags, const char *rawdata, cl_uint index)
{
	size_t		unitsz = sizeof(double) * GEOM_FLAGS_NDIMS(flags);

	return rawdata + unitsz * index;
}

STATIC_INLINE(void)
loadPoint2d(POINT2D *po, cl_uint flags, const char *rawdata, cl_uint index)
{
	const void *ptr = __getPointPtr(flags, rawdata, index);

	memcpy(po, ptr, sizeof(POINT2D));
}

STATIC_INLINE(void)
loadPoint3d(POINT3D *po, cl_uint flags, const char *rawdata, cl_uint index)
{
	const void *ptr = __getPointPtr(flags, rawdata, index);

	memcpy(po, ptr, sizeof(POINT3D));
}

STATIC_INLINE(void)
loadPoint4d(POINT4D *po, cl_uint flags, const char *rawdata, cl_uint index)
{
	const void *ptr = __getPointPtr(flags, rawdata, index);

	memcpy(po, ptr, sizeof(POINT4D));
}

/* ================================================================
 *
 * GSERIALIZED v1/v2 (see, gserialized1.h and gserialized2.h)
 *
 * ================================================================
 */
STATIC_INLINE(cl_int)
__gserialized_get_srid(const __GSERIALIZED *gs)
{
	cl_int		srid;

	/* Only the first 21 bits are set. Slide up and back to pull
	 * the negative bits down, if we need them. */
	srid = (((cl_uint)gs->srid[0] << 16) |
			((cl_uint)gs->srid[1] <<  8) |
			((cl_uint)gs->srid[0]));
	srid = (srid << 11) >> 11;
	/* 0 is our internal unknown value */
	return (srid == 0 ? SRID_UNKNOWN : srid);
}

STATIC_FUNCTION(pg_geometry_t)
__geometry_datum_ref_v1(kern_context *kcxt, void *addr, cl_int sz)
{
	/* see lwgeom_from_gserialized1() */
	__GSERIALIZED  *gs = (__GSERIALIZED *)addr;
	pg_geometry_t	geom;
	cl_ushort		geom_flags = 0;
	char		   *rawdata = gs->data;

	memset(&geom, 0, sizeof(pg_geometry_t));
	if ((gs->gflags & G1FLAG_Z) != 0)
		geom_flags |= GEOM_FLAG__Z;
	if ((gs->gflags & G1FLAG_M) != 0)
		geom_flags |= GEOM_FLAG__M;
	if ((gs->gflags & G1FLAG_BBOX) != 0)
		geom_flags |= GEOM_FLAG__BBOX;
	if ((gs->gflags & G1FLAG_GEODETIC) != 0)
		geom_flags |= GEOM_FLAG__GEODETIC;
	if ((gs->gflags & G1FLAG_SOLID) != 0)
		geom_flags |= GEOM_FLAG__SOLID;

	geom.flags = geom_flags;
	geom.srid = __gserialized_get_srid(gs);
	if ((geom.flags & GEOM_FLAG__BBOX) != 0)
	{
		geom.bbox = (geom_bbox *)rawdata;
		rawdata += geometry_bbox_size(geom.flags);
	}
	memcpy(&geom.type, rawdata, sizeof(cl_uint));
	rawdata += sizeof(cl_uint);
	memcpy(&geom.nitems, rawdata, sizeof(cl_uint));
	rawdata += sizeof(cl_uint);

	assert(rawdata <= (char *)addr + sz);
	geom.rawsize = sz - (rawdata - (char *)addr);
	geom.rawdata = rawdata;

	/*
	 * NOTE: Unlike CPU version of lwgeom_from_gserialized1(),
	 * we don't generate boundary box here, even if raw geometry
	 * datum has no boundary box unexpectedly. It is mandatorily
	 * generated by PostGIS, thus the code to construct bounday
	 * box just consumes device memory footpoint, and we have no
	 * proper way for code debugging.
	 */
	return geom;
}

/* flags of GSERIALIZED v2 */

STATIC_FUNCTION(pg_geometry_t)
__geometry_datum_ref_v2(kern_context *kcxt, void *addr, cl_int sz)
{
	/* see lwgeom_from_gserialized2() */
	__GSERIALIZED  *gs = (__GSERIALIZED *)addr;
	pg_geometry_t	geom;
	cl_uchar		gs_flags = gs->gflags;
	cl_ushort		geom_flags = 0;
	char		   *rawdata = gs->data;

	memset(&geom, 0, sizeof(pg_geometry_t));

	/* parse version.2 flags */
	if ((gs_flags & G2FLAG_Z) != 0)
		geom_flags |= GEOM_FLAG__Z;
	if ((gs_flags & G2FLAG_M) != 0)
		geom_flags |= GEOM_FLAG__M;
	if ((gs_flags & G2FLAG_BBOX) != 0)
		geom_flags |= GEOM_FLAG__BBOX;
    if ((gs_flags & G2FLAG_GEODETIC) != 0)
		geom_flags |= G1FLAG_GEODETIC;
	if ((gs_flags & G2FLAG_EXTENDED) != 0)
	{
		cl_ulong    ex_flags;

		memcpy(&ex_flags, rawdata, sizeof(cl_ulong));
		if ((ex_flags & G2FLAG_X_SOLID) != 0)
			geom_flags |= GEOM_FLAG__SOLID;
		rawdata += sizeof(cl_ulong);
	}
	geom.flags = geom_flags;
	geom.srid = __gserialized_get_srid(gs);
	if ((geom.flags & GEOM_FLAG__BBOX) != 0)
	{
		geom.bbox = (geom_bbox *)rawdata;
		rawdata += geometry_bbox_size(geom.flags);
	}
	memcpy(&geom.type, rawdata, sizeof(cl_uint));
	rawdata += sizeof(cl_uint);
	memcpy(&geom.nitems, rawdata, sizeof(cl_uint));
	rawdata += sizeof(cl_uint);

	assert(rawdata <= (char *)addr + sz);
	geom.rawsize = sz - (rawdata - (char *)addr);
	geom.rawdata = rawdata;

	/*
	 * NOTE: Unlike CPU version of lwgeom_from_gserialized1(),
	 * we don't generate boundary box here, even if raw geometry
	 * datum has no boundary box unexpectedly. It is mandatorily
	 * generated by PostGIS, thus the code to construct bounday
	 * box just consumes device memory footpoint, and we have no
	 * proper way for code debugging.
	 */
	return geom;
}

DEVICE_FUNCTION(pg_geometry_t)
pg_geometry_datum_ref(kern_context *kcxt, void *addr)
{
	pg_geometry_t	result;

	if (!addr)
	{
		memset(&result, 0, sizeof(pg_geometry_t));
		result.isnull = true;
	}
	else
	{
		__GSERIALIZED  *g = (__GSERIALIZED *)VARDATA_ANY(addr);
		cl_int			sz = VARSIZE_ANY_EXHDR(addr);

		if ((g->gflags & G2FLAG_VER_0) != 0)
			result = __geometry_datum_ref_v2(kcxt, g, sz);
		else
			result = __geometry_datum_ref_v1(kcxt, g, sz);
	}
	return result;
}

DEVICE_FUNCTION(void)
pg_datum_ref(kern_context *kcxt, pg_geometry_t &result, void *addr)
{
	result = pg_geometry_datum_ref(kcxt, addr);
}

DEVICE_FUNCTION(void)
pg_datum_ref_slot(kern_context *kcxt,
				  pg_geometry_t &result,
				  cl_char dclass, Datum datum)
{
	if (dclass == DATUM_CLASS__NULL)
		result = pg_geometry_datum_ref(kcxt, NULL);
	else if (dclass == DATUM_CLASS__GEOMETRY)
		memcpy(&result, DatumGetPointer(datum), sizeof(pg_geometry_t));
	else
	{
		assert(dclass == DATUM_CLASS__NORMAL);
		result = pg_geometry_datum_ref(kcxt, (char *)datum);
	}
}

DEVICE_FUNCTION(pg_geometry_t)
pg_geometry_param(kern_context *kcxt, cl_uint param_id)
{
	kern_parambuf *kparams = kcxt->kparams;
	pg_geometry_t result;

	if (param_id < kparams->nparams &&
		kparams->poffset[param_id] > 0)
	{
		void   *addr = ((char *)kparams +
						kparams->poffset[param_id]);
		result = pg_geometry_datum_ref(kcxt, addr);
	}
	else
	{
		memset(&result, 0, sizeof(pg_geometry_t));
		result.isnull = true;
	}
	return result;
}

DEVICE_FUNCTION(cl_int)
pg_datum_store(kern_context *kcxt,
			   pg_geometry_t datum,
			   cl_char &dclass,
			   Datum &value)
{
	if (datum.isnull)
		dclass = DATUM_CLASS__NULL;
	else
	{
		pg_geometry_t *temp;

		temp = (pg_geometry_t *)
			kern_context_alloc(kcxt, sizeof(pg_geometry_t));
		if (temp)
		{
			memcpy(temp, &datum, sizeof(pg_geometry_t));
			dclass = DATUM_CLASS__GEOMETRY;
			value = PointerGetDatum(temp);
			return sizeof(pg_geometry_t);
		}
		STROM_EREPORT(kcxt, ERRCODE_OUT_OF_MEMORY,
					  "out of memory");
		dclass = DATUM_CLASS__NULL;
	}
	return 0;
}

/* ================================================================
 *
 * Basic geometry constructor and related
 *
 * ================================================================
 */
DEVICE_FUNCTION(pg_geometry_t)
pgfn_st_setsrid(kern_context *kcxt, pg_geometry_t arg1, pg_int4_t arg2)
{
	if (arg1.isnull || arg2.isnull)
		arg1.isnull = true;
	else
	{
		/* see clamp_srid */
		cl_int	srid = arg2.value;

		if (srid <= 0)
			srid = SRID_UNKNOWN;
		else if (srid > SRID_MAXIMUM)
			srid = SRID_USER_MAXIMUM + 1 +
				(srid % (SRID_MAXIMUM - SRID_USER_MAXIMUM - 1));

		arg1.srid = srid;
	}
	return arg1;
}

DEVICE_FUNCTION(pg_geometry_t)
pgfn_st_makepoint2(kern_context *kcxt, pg_float8_t x, pg_float8_t y)
{
	pg_geometry_t	geom;

	memset(&geom, 0, sizeof(pg_geometry_t));
	if (x.isnull || y.isnull)
		geom.isnull = true;
	else
	{
		cl_double  *rawdata = (cl_double *)
			kern_context_alloc(kcxt, 2 * sizeof(cl_double));

		if (!rawdata)
		{
			STROM_CPU_FALLBACK(kcxt, ERRCODE_OUT_OF_MEMORY,
							   "out of memory");
			geom.isnull = true;
		}
		else
		{
			rawdata[0] = x.value;
			rawdata[1] = y.value;

			geom.type = GEOM_POINTTYPE;
			geom.flags = 0;
			geom.srid = SRID_UNKNOWN;
			geom.nitems = 1;
			geom.rawsize = 2 * sizeof(cl_double);
			geom.rawdata = (char *)rawdata;
		}
	}
	return geom;
}

DEVICE_FUNCTION(pg_geometry_t)
pgfn_st_makepoint3(kern_context *kcxt,
				   pg_float8_t x, pg_float8_t y, pg_float8_t z)
{
	pg_geometry_t	geom;

	memset(&geom, 0, sizeof(pg_geometry_t));
	if (x.isnull || y.isnull || z.isnull)
		geom.isnull = true;
	else
	{
		cl_double  *rawdata = (cl_double *)
			kern_context_alloc(kcxt, 3 * sizeof(cl_double));

		if (!rawdata)
		{
			STROM_CPU_FALLBACK(kcxt, ERRCODE_OUT_OF_MEMORY,
							   "out of memory");
			geom.isnull = true;
		}
		else
		{
			rawdata[0] = x.value;
			rawdata[1] = y.value;
			rawdata[2] = z.value;

			geom.type = GEOM_POINTTYPE;
			geom.flags = GEOM_FLAG__Z;
			geom.srid = SRID_UNKNOWN;
			geom.nitems = 1;
			geom.rawsize = 3 * sizeof(cl_double);
			geom.rawdata = (char *)rawdata;
		}
	}
	return geom;
}

DEVICE_FUNCTION(pg_geometry_t)
pgfn_st_makepoint4(kern_context *kcxt,
				   pg_float8_t x, pg_float8_t y,
				   pg_float8_t z, pg_float8_t m)
{
	pg_geometry_t	geom;

	memset(&geom, 0, sizeof(pg_geometry_t));
	if (x.isnull || y.isnull || z.isnull || m.isnull)
		geom.isnull = true;
	else
	{
		cl_double  *rawdata = (cl_double *)
			kern_context_alloc(kcxt, 4 * sizeof(cl_double));

		if (!rawdata)
		{
			STROM_CPU_FALLBACK(kcxt, ERRCODE_OUT_OF_MEMORY,
							   "out of memory");
			geom.isnull = true;
		}
		else
		{
			rawdata[0] = x.value;
			rawdata[1] = y.value;
			rawdata[2] = z.value;
			rawdata[3] = m.value;

			geom.type = GEOM_POINTTYPE;
			geom.flags = GEOM_FLAG__Z | GEOM_FLAG__M;
			geom.srid = SRID_UNKNOWN;
			geom.nitems = 1;
			geom.rawsize = 2 * sizeof(cl_double);
			geom.rawdata = (char *)rawdata;
		}
	}
	return geom;
}
