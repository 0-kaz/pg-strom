const char *pgstrom_opencl_numeric_code =
  "/*\n"
  " * opencl_numeric.h\n"
  " *\n"
  " * Collection of numeric functions for OpenCL devices\n"
  " * --\n"
  " * Copyright 2011-2014 (C) KaiGai Kohei <kaigai@kaigai.gr.jp>\n"
  " * Copyright 2014 (C) The PG-Strom Development Team\n"
  " *\n"
  " * This program is free software; you can redistribute it and/or modify\n"
  " * it under the terms of the GNU General Public License version 2 as\n"
  " * published by the Free Software Foundation.\n"
  " *\n"
  " * This program is distributed in the hope that it will be useful,\n"
  " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
  " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
  " * GNU General Public License for more details.\n"
  " */\n"
  "#ifndef OPENCL_NUMERIC_H\n"
  "#define OPENCL_NUMERIC_H\n"
  "#ifdef OPENCL_DEVICE_CODE\n"
  "\n"
  "\n"
  "#define CL_CHAR_BIT\t\t\t8\n"
  "\n"
  "\n"
  "/* PostgreSQL numeric data type */\n"
  "#if 0\n"
  "#define PG_DEC_DIGITS\t\t1\n"
  "#define PG_NBASE\t\t\t10\n"
  "typedef cl_char\t\tNumericDigit;\n"
  "#endif\n"
  "\n"
  "#if 0\n"
  "#define PG_DEC_DIGITS\t\t2\n"
  "#define PG_NBASE\t\t\t100\n"
  "typedef cl_char\t\tNumericDigit;\n"
  "#endif\n"
  "\n"
  "#if 1\n"
  "#define PG_DEC_DIGITS\t\t4\n"
  "#define PG_NBASE\t\t\t10000\n"
  "typedef cl_short\tNumericDigit;\n"
  "#endif\n"
  "\n"
  "#define PG_MAX_DIGITS\t\t18\t/* Max digits of 57 bit mantissa. */\n"
  "#define PG_MAX_DATA\t\t\t((PG_MAX_DIGITS + PG_DEC_DIGITS - 1) / \\\n"
  "\t\t\t\t\t\t\t PG_DEC_DIGITS)\n"
  "\n"
  "struct NumericShort\n"
  "{\n"
  "\tcl_ushort\t\tn_header;\t\t\t\t/* Sign + display scale + weight */\n"
  "\tNumericDigit\tn_data[PG_MAX_DATA];\t/* Digits */\n"
  "};\n"
  "\n"
  "struct NumericLong\n"
  "{\n"
  "\tcl_ushort\t\tn_sign_dscale;\t\t\t/* Sign + display scale */\n"
  "\tcl_short\t\tn_weight;\t\t\t\t/* Weight of 1st digit\t*/\n"
  "\tNumericDigit\tn_data[PG_MAX_DATA];\t/* Digits */\n"
  "};\n"
  "\n"
  "union NumericChoice\n"
  "{\n"
  "\tcl_ushort\t\t\tn_header;\t\t\t/* Header word */\n"
  "\tstruct NumericLong\tn_long;\t\t\t\t/* Long form (4-byte header) */\n"
  "\tstruct NumericShort\tn_short;\t\t\t/* Short form (2-byte header) */\n"
  "};\n"
  "\n"
  "// struct NumericData\n"
  "// {\n"
  "// \tint32\t\tvl_len_;\t\t/* varlena header (do not touch directly!) */\n"
  "// \tunion NumericChoice choice; /* choice of format */\n"
  "// };\n"
  "\n"
  "\n"
  "#define NUMERIC_SIGN_MASK\t0xC000\n"
  "#define NUMERIC_POS\t\t\t0x0000\n"
  "#define NUMERIC_NEG\t\t\t0x4000\n"
  "#define NUMERIC_SHORT\t\t0x8000\n"
  "#define NUMERIC_NAN\t\t\t0xC000\n"
  "\n"
  "#define NUMERIC_FLAGBITS(n)\t\t((n)->n_header & NUMERIC_SIGN_MASK)\n"
  "#define NUMERIC_IS_NAN(n)\t\t(NUMERIC_FLAGBITS(n) == NUMERIC_NAN)\n"
  "#define NUMERIC_IS_SHORT(n)\t\t(NUMERIC_FLAGBITS(n) == NUMERIC_SHORT)\n"
  "\n"
  "#define NUMERIC_SHORT_SIGN_MASK\t\t\t0x2000\n"
  "#define NUMERIC_SHORT_DSCALE_MASK\t\t0x1F80\n"
  "#define NUMERIC_SHORT_DSCALE_SHIFT\t\t7\n"
  "#define NUMERIC_SHORT_DSCALE_MAX\t\t(NUMERIC_SHORT_DSCALE_MASK >> \\\n"
  "\t\t\t\t\t\t\t\t\t\t NUMERIC_SHORT_DSCALE_SHIFT)\n"
  "#define NUMERIC_SHORT_WEIGHT_SIGN_MASK\t0x0040\n"
  "#define NUMERIC_SHORT_WEIGHT_MASK\t\t0x003F\n"
  "#define NUMERIC_SHORT_WEIGHT_MAX\t\tNUMERIC_SHORT_WEIGHT_MASK\n"
  "#define NUMERIC_SHORT_WEIGHT_MIN\t\t(-(NUMERIC_SHORT_WEIGHT_MASK+1))\n"
  "\n"
  "#define NUMERIC_DSCALE_MASK\t\t\t0x3FFF\n"
  "\n"
  "#define NUMERIC_DIGITS(n)   (NUMERIC_IS_SHORT(n) ? (n)->n_short.n_data : (n)->n_long.n_data)\n"
  "#define NUMERIC_SIGN(n) \t(NUMERIC_IS_SHORT(n) ? (((n)->n_short.n_header & NUMERIC_SHORT_SIGN_MASK) ? NUMERIC_NEG : NUMERIC_POS) : NUMERIC_FLAGBITS(n))\n"
  "#define NUMERIC_DSCALE(n)\t(NUMERIC_IS_SHORT(n) ? ((n)->n_short.n_header & NUMERIC_SHORT_DSCALE_MASK) >> NUMERIC_SHORT_DSCALE_SHIFT : ((n)->n_long.n_sign_dscale & NUMERIC_DSCALE_MASK))\n"
  "#define NUMERIC_WEIGHT(n)\t(NUMERIC_IS_SHORT(n) ? (((n)->n_short.n_header & NUMERIC_SHORT_WEIGHT_SIGN_MASK ? ~NUMERIC_SHORT_WEIGHT_MASK : 0) | ((n)->n_short.n_header & NUMERIC_SHORT_WEIGHT_MASK)) : ((n)->n_long.n_weight))\n"
  "\n"
  "\n"
  "/* IEEE 754 FORMAT */\n"
  "#if 0\n"
  "#define PG_FLOAT_SIGN_POS\t31\n"
  "#define PG_FLOAT_SIGN_BITS\t1\n"
  "#define PG_FLOAT_EXPO_POS\t23\n"
  "#define PG_FLOAT_EXPO_BITS\t8\n"
  "#define PG_FLOAT_MANT_POS\t0\n"
  "#define PG_FLOAT_MANT_BITS\t23\n"
  "\n"
  "#define PG_DOUBLE_SIGN_POS\t63\n"
  "#define PG_DOUBLE_SIGN_BITS\t1\n"
  "#define PG_DOUBLE_EXPO_POS\t52\n"
  "#define PG_DOUBLE_EXPO_BITS\t11\n"
  "#define PG_DOUBLE_MANT_POS\t0\n"
  "#define PG_DOUBLE_MANT_BITS\t52\n"
  "#endif\n"
  "\n"
  "\n"
  "/*\n"
  " * PG-Strom internal representation of NUMERIC data type\n"
  " *\n"
  " * Even though the nature of NUMERIC data type is variable-length and error-\n"
  " * less mathmatical operation, we assume most of numeric usage can be hosted\n"
  " * within 64bit variable. A small number anomaly can be calculated by CPU,\n"
  " * so we focus on the major portion of use-cases.\n"
  " * Internal data format of numeric is 64-bit integer that is separated to\n"
  " * (1) 6bit exponents based on 10, (2) 1bit sign bit, and (3) 57bit mantissa.\n"
  " * Function that can handle NUMERIC data type will set StromError_CpuReCheck,\n"
  " * if it detects overflow during calculation.\n"
  " */\n"
  "typedef struct {\n"
  "\tcl_ulong\tvalue;\n"
  "\tbool\t\tisnull;\n"
  "} pg_numeric_t;\n"
  "\n"
  "#endif\t/* OPENCL_DEVICE_CODE */\n"
  "\n"
  "#define PG_NUMERIC_EXPONENT_BITS\t6\n"
  "#define PG_NUMERIC_EXPONENT_POS\t\t58\n"
  "#define PG_NUMERIC_EXPONENT_MASK\t(((0x1UL << (PG_NUMERIC_EXPONENT_BITS)) - 1) << (PG_NUMERIC_EXPONENT_POS))\n"
  "#define PG_NUMERIC_EXPONENT_MAX\t\t((1 << ((PG_NUMERIC_EXPONENT_BITS) - 1)) - 1)\n"
  "#define PG_NUMERIC_EXPONENT_MIN\t\t(0 - (1 << ((PG_NUMERIC_EXPONENT_BITS) - 1)))\n"
  "\n"
  "#define PG_NUMERIC_SIGN_BITS\t\t1\n"
  "#define PG_NUMERIC_SIGN_POS\t\t\t57\n"
  "#define PG_NUMERIC_SIGN_MASK\t\t(((0x1UL << (PG_NUMERIC_SIGN_BITS)) - 1) << (PG_NUMERIC_SIGN_POS))\n"
  "\n"
  "#define PG_NUMERIC_MANTISSA_BITS\t57\n"
  "#define PG_NUMERIC_MANTISSA_POS\t\t0\n"
  "#define PG_NUMERIC_MANTISSA_MASK\t(((0x1UL << (PG_NUMERIC_MANTISSA_BITS)) - 1) << (PG_NUMERIC_MANTISSA_POS))\n"
  "#define PG_NUMERIC_MANTISSA_MAX\t\t((0x1UL << (PG_NUMERIC_MANTISSA_BITS)) - 1)\n"
  "\n"
  "#define PG_NUMERIC_EXPONENT(num)\t((cl_long)(num) >> 58)\n"
  "#define PG_NUMERIC_SIGN(num)\t\t(((num) & PG_NUMERIC_SIGN_MASK) != 0)\n"
  "#define PG_NUMERIC_MANTISSA(num)\t((num) & PG_NUMERIC_MANTISSA_MASK)\n"
  "#define PG_NUMERIC_SET(expo,sign,mant)\t\t\t\t\t\t\t\\\n"
  "\t((cl_ulong)((cl_long)(expo) << 58) |\t\t\t\t\t\t\\\n"
  "\t ((sign) != 0 ? PG_NUMERIC_SIGN_MASK : 0UL) |\t\t\t\t\\\n"
  "\t ((mant) & PG_NUMERIC_MANTISSA_MASK))\n"
  "\n"
  "#ifdef OPENCL_DEVICE_CODE\n"
  "\n"
  "static pg_numeric_t\n"
  "pg_numeric_from_varlena(__private int *errcode, __global varlena *vl_val)\n"
  "{\n"
  "\tpg_numeric_t\t\tresult;\n"
  "\tunion NumericChoice\tnumData;\n"
  "\n"
  "\n"
  "\tif (vl_val == NULL)\n"
  "\t{\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\n"
  "\t__global cl_char *pSrc = VARDATA_ANY(vl_val);\n"
  "\tcl_int len = VARSIZE_ANY_EXHDR(vl_val);\n"
  "\n"
  "\tif (sizeof(numData) < len) {\n"
  "\t\t// Numeric data is too large.\n"
  "\t\t// PG-Strom numeric type support 18 characters.\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\t\t*errcode      = StromError_CpuReCheck;\n"
  "\t\treturn result;\n"
  "\t}\n"
  "\n"
  "\t// Once data copy to private memory for alignment.\n"
  "    // memcpy(&numData, pSrc, len);\n"
  "\t{\n"
  "\t\t// OpenCL memcpy does not support private memory.\n"
  "\t\t__private cl_char *dst = (__private cl_char *) &numData;\n"
  "\t\t__global  cl_char *src = (__global  cl_char *) pSrc;\n"
  "\t\tfor(int i=0; i<len; i++) {\n"
  "\t\t\tdst[i] = src[i];\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\t// Convert PG-Strom numeric type from PostgreSQL numeric type.\n"
  "\t{\n"
  "\t\tint\t\t     sign\t = NUMERIC_SIGN(&numData);\n"
  "\t\tint\t\t     expo;\n"
  "\t\tcl_ulong     mant;\n"
  "\t\tint \t     weight  = NUMERIC_WEIGHT(&numData);\n"
  "//\t\tint\t\t     dscale  = NUMERIC_DSCALE(&numData);\n"
  "\t\tNumericDigit *digits = NUMERIC_DIGITS(&numData);\n"
  "\t\tint\t\t\t offset  = (unsigned long)digits - (unsigned long)&numData;\n"
  "\t\tint \t     ndigits = (len - offset) / sizeof(NumericDigit);\n"
  "\n"
  "\t\tint\t\t\t i, base;\n"
  "\t\tcl_ulong\t mantLast;\n"
  "\n"
  "\n"
  "\t\t// Numeric value is 0, if ndigits is 0. \n"
  "\t\tif (ndigits == 0) {\n"
  "\t\t\tresult.isnull = false;\n"
  "\t\t\tresult.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\t\treturn result;\n"
  "\t\t}\n"
  "\n"
  "\t\t// Generate exponent.\n"
  "\t\texpo = (weight - (ndigits - 1)) * PG_DEC_DIGITS;\n"
  "\n"
  "\t\t// Generate mantissa.\n"
  "\t\tmant = 0;\n"
  "\t\tfor (i=0; i<ndigits-1; i++) {\n"
  "\t\t\tmant = mant * PG_NBASE + digits[i];\n"
  "\t\t}\n"
  "\n"
  "\t\tbase     = PG_NBASE;\n"
  "\t\tmantLast = digits[i];\n"
  "\t\tfor (i=0; i<PG_DEC_DIGITS; i++) {\n"
  "\t\t\tif (mantLast % 10 == 0) {\n"
  "\t\t\t\texpo ++;\n"
  "\t\t\t\tbase     /= 10;\n"
  "\t\t\t\tmantLast /= 10;\n"
  "\t\t\t} else {\n"
  "\t\t\t\tbreak;\n"
  "\t\t\t}\n"
  "\t\t}\n"
  "\n"
  "\t\t// overflow check\n"
  "\t\tif ((mant * base) / base != mant) {\n"
  "\t\t\tresult.isnull = true;\n"
  "\t\t\tresult.value  = 0;\n"
  "\t\t\t*errcode      = StromError_CpuReCheck;\n"
  "\t\t\treturn result;\n"
  "\t\t}\n"
  "\n"
  "\t\tmant = mant * base + mantLast;\n"
  "\n"
  "\n"
  "\t\t// Normalize\n"
  "\t\twhile (mant % 10 == 0  &&  expo < PG_NUMERIC_EXPONENT_MAX) {\n"
  "\t\t\tmant /= 10;\n"
  "\t\t\texpo ++;\n"
  "\t\t}\n"
  "\n"
  "\t\tif (PG_NUMERIC_EXPONENT_MAX < expo) {\n"
  "\t\t\t// Exponent is overflow.\n"
  "\t\t\tint expoDiff = expo - PG_NUMERIC_EXPONENT_MAX;\n"
  "\t\t\tint\t\ti;\n"
  "\t\t\tulong\tmag;\n"
  "\n"
  "\t\t\tif (PG_MAX_DIGITS <= expoDiff) {\n"
  "\t\t\t\t// magnify is overflow\n"
  "\t\t\t\tresult.isnull = true;\n"
  "\t\t\t\tresult.value  = 0;\n"
  "\t\t\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\t\t\treturn result;\n"
  "\t\t\t}\n"
  "\n"
  "\t\t\tfor (i=0, mag=1; i < expoDiff; i++) {\n"
  "\t\t\t\tmag *= 10;\n"
  "\t\t\t}\n"
  "\n"
  "\t\t\tif ((mant * mag) / mag != mant) {\n"
  "\t\t\t\tresult.isnull = true;\n"
  "\t\t\t\tresult.value  = 0;\n"
  "\t\t\t\t*errcode      = StromError_CpuReCheck;\n"
  "\t\t\t\treturn result;\n"
  "\t\t\t}\n"
  "\n"
  "\t\t\texpo -= expoDiff;\n"
  "\t\t\tmant *= mag;\n"
  "\t\t}\n"
  "\n"
  "\t\t// Error check\n"
  "\t\tif (expo < PG_NUMERIC_EXPONENT_MIN || PG_NUMERIC_EXPONENT_MAX < expo ||\n"
  "\t\t\t(mant & ~PG_NUMERIC_MANTISSA_MASK)) {\n"
  "\t\t\tresult.isnull = true;\n"
  "\t\t\tresult.value  = 0;\n"
  "\t\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\t\treturn result;\n"
  "\t\t}\n"
  "\n"
  "\t\t// Set value to PG_Strom numeric type\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = PG_NUMERIC_SET(expo, sign, mant);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/*\n"
  " * pg_numeric_vref\n"
  " *\n"
  " * It contains special case handling due to internal numeric format.\n"
  " * If kds intends to have varlena format (PostgreSQL compatible), it tries\n"
  " * to reference varlena variable. Otherwise, in case when attlen > 0, it\n"
  " * tries to fetch fixed-length variable.\n"
  " */\n"
  "static pg_numeric_t\n"
  "pg_numeric_vref(__global kern_data_store *kds,\n"
  "\t\t\t\t__global kern_data_store *ktoast,\n"
  "\t\t\t\t__private int *errcode,\n"
  "\t\t\t\tcl_uint colidx,\n"
  "\t\t\t\tcl_uint rowidx)\n"
  "{\n"
  "\t__global void  *addr = kern_get_datum(kds,ktoast,colidx,rowidx);\n"
  "\tpg_numeric_t\tresult;\n"
  "\n"
  "\tif (!addr)\n"
  "\t\tresult.isnull = true;\n"
  "\telse if (kds->colmeta[colidx].attlen < 0)\n"
  "\t\tresult = pg_numeric_from_varlena(errcode, (__global varlena *)addr);\n"
  "\telse\n"
  "\t{\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value  = *((__global cl_ulong *) addr);\n"
  "\t}\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "/* pg_numeric_vstore() is same as template */\n"
  "STROMCL_SIMPLE_VARSTORE_TEMPLATE(numeric, cl_ulong)\n"
  "\n"
  "static pg_numeric_t\n"
  "pg_numeric_param(__global kern_parambuf *kparams,\n"
  "\t\t\t\t __private int *errcode,\n"
  "\t\t\t\t cl_uint param_id)\n"
  "{\n"
  "\t__global varlena *vl_val;\n"
  "\tpg_numeric_t\tresult;\n"
  "\n"
  "\tif (param_id < kparams->nparams &&\n"
  "\t\tkparams->poffset[param_id] > 0)\n"
  "\t{\n"
  "\t\tvl_val = (__global varlena *)\n"
  "\t\t\t((__global char *)kparams + kparams->poffset[param_id]);\n"
  "\t\t/* only uncompressed & inline datum */\n"
  "\t\tif (VARATT_IS_4B_U(vl_val) || VARATT_IS_1B(vl_val))\n"
  "\t\t\treturn pg_numeric_from_varlena(errcode, vl_val);\n"
  "\n"
  "\t\tSTROM_SET_ERROR(errcode, StromError_CpuReCheck);\n"
  "\t}\n"
  "\tresult.isnull = true;\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_bool_t\n"
  "pgfn_numeric_isnull(__private int *errcode,\n"
  "\t\t\t\t\tpg_numeric_t arg)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = false;\n"
  "\tresult.value  = arg.isnull;\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_bool_t\n"
  "pgfn_numeric_isnotnull(__private int *errcode,\n"
  "\t\t\t\t\t   pg_numeric_t arg)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tresult.isnull = false;\n"
  "\tresult.value = !arg.isnull;\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "\n"
  "/* to avoid conflicts with auto-generated data type */\n"
  "#define PG_NUMERIC_TYPE_DEFINED\n"
  "\n"
  "/*\n"
  " * Numeric format translation functions\n"
  " * ----------------------------------------------------------------\n"
  " */\n"
  "\n"
  "/* pg_int2_t */\n"
  "#ifndef PG_INT2_TYPE_DEFINED\n"
  "#define PG_INT2_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(int2, cl_short)\n"
  "#endif\n"
  "/* pg_int4_t */\n"
  "#ifndef PG_INT4_TYPE_DEFINED\n"
  "#define PG_INT4_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(int4, cl_int)\n"
  "#endif\n"
  "/* pg_int8_t */\n"
  "#ifndef PG_INT8_TYPE_DEFINED\n"
  "#define PG_INT8_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(int8, cl_long)\n"
  "#endif\n"
  "/* pg_float4_t */\n"
  "#ifndef PG_FLOAT4_TYPE_DEFINED\n"
  "#define PG_FLOAT4_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(float4, cl_float)\n"
  "#endif\n"
  "/* pg_float8_t */\n"
  "#ifndef PG_FLOAT8_TYPE_DEFINED\n"
  "#define PG_FLOAT8_TYPE_DEFINED\n"
  "STROMCL_SIMPLE_TYPE_TEMPLATE(float8, cl_double)\n"
  "#endif\n"
  "\n"
  "\n"
  "\n"
  "static pg_int8_t\n"
  "numeric_to_integer(__private int *errcode, pg_numeric_t arg, cl_int size)\n"
  "{\n"
  "\tpg_int8_t\tv;\n"
  "\n"
  "\n"
  "\tif (arg.isnull == true) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tint\t     expo = PG_NUMERIC_EXPONENT(arg.value);\n"
  "\tint\t\t sign = PG_NUMERIC_SIGN(arg.value);\n"
  "\tcl_ulong mant = PG_NUMERIC_MANTISSA(arg.value);\n"
  "\t\n"
  "\tif (mant == 0) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = 0;\n"
  "\t}\n"
  "\n"
  "\tint  exp = abs(expo);\n"
  "\tlong mag = 1;\n"
  "\tfor(int i=0; i<exp; i++) {\n"
  "\t\tif((mag * 10) < mag) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\t\tmag *= 10;\n"
  "\t}\n"
  "\n"
  "\tif (expo < 0) {\n"
  "\t\t// Round off if exponent is minus.\n"
  "\t\tmant = (mant + mag/2) / mag;\n"
  "\n"
  "\t} else {\n"
  "\t\t// Overflow check\n"
  "\t\tif ((mant * mag) / mag != mant) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\tmant *= mag;\n"
  "\t}\n"
  "\n"
  "\t// Overflow check\n"
  "\tint      nbits       = size * CL_CHAR_BIT;\n"
  "\tcl_ulong max_val     = (1UL << (nbits - 1)) - 1;\n"
  "\tcl_ulong abs_min_val = (1UL << (nbits - 1));\n"
  "\tif((sign == 0 && max_val < mant) || (sign != 0 && abs_min_val < mant)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tv.isnull = false;\n"
  "\tv.value  = (sign == 0) ? mant : (-mant);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_float8_t\n"
  "numeric_to_float(__private int *errcode, pg_numeric_t arg)\n"
  "{\n"
  "\tpg_float8_t\tv;\n"
  "\n"
  "\n"
  "\tif (arg.isnull == true) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\n"
  "\tint   expo = PG_NUMERIC_EXPONENT(arg.value);\n"
  "\tint\t  sign = PG_NUMERIC_SIGN(arg.value);\n"
  "\tulong mant = PG_NUMERIC_MANTISSA(arg.value);\n"
  "\n"
  "\tif (mant == 0) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\n"
  "\tdouble\tfvalue = (double)mant * exp10((double)expo);\n"
  "\n"
  "\tif (isinf(fvalue) || isnan(fvalue)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tv.isnull = false;\n"
  "\tv.value  = (sign == 0) ? fvalue : (-fvalue);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_int2_t\n"
  "pgfn_numeric_int2(__private int *errcode, pg_numeric_t arg)\n"
  "{\n"
  "\tpg_int2_t v;\n"
  "\tpg_int8_t tmp = numeric_to_integer(errcode, arg, sizeof(v.value));\n"
  "\n"
  "\tv.isnull = tmp.isnull;\n"
  "\tv.value  = tmp.value;\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_int4_t\n"
  "pgfn_numeric_int4(__private int *errcode, pg_numeric_t arg)\n"
  "{\n"
  "\tpg_int4_t v;\n"
  "\tpg_int8_t tmp = numeric_to_integer(errcode, arg, sizeof(v.value));\n"
  "\n"
  "\tv.isnull = tmp.isnull;\n"
  "\tv.value  = tmp.value;\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_int8_t\n"
  "pgfn_numeric_int8(__private int *errcode, pg_numeric_t arg)\n"
  "{\n"
  "\tpg_int8_t v;\n"
  "\treturn numeric_to_integer(errcode, arg, sizeof(v.value));\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_float4_t\n"
  "pgfn_numeric_float4(__private int *errcode, pg_numeric_t arg)\n"
  "{\n"
  "\n"
  "\tpg_float8_t tmp = numeric_to_float(errcode, arg);\n"
  "\tpg_float4_t\tv   = { (cl_float)tmp.value, tmp.isnull };\n"
  "\n"
  "\tif (v.isnull == false  &&  isinf(v.value)) {\n"
  "\t\tv.isnull\t= true;\n"
  "\t\tv.value\t\t= 0;\n"
  "\t\t*errcode\t= StromError_CpuReCheck;\n"
  "\t}\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_float8_t\n"
  "pgfn_numeric_float8(__private int *errcode, pg_numeric_t arg)\n"
  "{\n"
  "\treturn numeric_to_float(errcode, arg);\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "integer_to_numeric(__private int *errcode, pg_int8_t arg, cl_int size)\n"
  "{\n"
  "\tpg_numeric_t\tv;\n"
  "\tint\t\t\t\tsign;\n"
  "\tint\t\t\t\texpo;\n"
  "\tcl_ulong\t\tmant;\n"
  "\n"
  "\n"
  "\tif (arg.isnull) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\t\t\n"
  "\tif (arg.value == 0) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tif (0 <= arg.value) {\n"
  "\t\tsign = 0;\n"
  "\t\tmant = arg.value;\n"
  "\t} else {\n"
  "\t\tsign = 1;\n"
  "\t\tmant = -arg.value;\n"
  "\t}\n"
  "\texpo = 0;\n"
  "\n"
  "\t// Normalize\n"
  "\twhile (mant % 10 == 0  &&  expo < PG_NUMERIC_EXPONENT_MAX) {\n"
  "\t\tmant /= 10;\n"
  "\t\texpo ++;\n"
  "\t}\n"
  "\n"
  "\tif(PG_NUMERIC_MANTISSA_BITS < size * CL_CHAR_BIT - 1) {\n"
  "\t\t// Error check\n"
  "\t\tif (mant & ~PG_NUMERIC_MANTISSA_MASK) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\tv.isnull = false;\n"
  "\tv.value  = PG_NUMERIC_SET(expo, sign, mant);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "float_to_numeric(__private int *errcode, pg_float8_t arg, int dig)\n"
  "{\n"
  "\tpg_numeric_t\tv;\n"
  "\n"
  "\n"
  "\tif (arg.isnull) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tif (isnan(arg.value) || isinf(arg.value)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tif (arg.value == 0.0) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\n"
  "\tint\t\tsign;\n"
  "\tdouble\tfval;\n"
  "\n"
  "\tif (0 <= arg.value) {\n"
  "\t\tsign = 0;\n"
  "\t\tfval = arg.value;\n"
  "\t} else {\n"
  "\t\tsign = 1;\n"
  "\t\tfval = -arg.value;\n"
  "\t}\n"
  "\n"
  "\tint\t\tfexpo = ceil(log10(fval)) + 1;\n"
  "\tdouble  fmant = fval * (double)exp10((double)(dig - fexpo));\n"
  "\tif(isinf(fmant)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tint\t\texpo  = fexpo - dig;\n"
  "\tulong\tmant;\n"
  "\n"
  "\tdouble  thrMax = exp10((double)(dig));\n"
  "\twhile(thrMax < fmant) {\n"
  "\t\tfmant /= 10;\n"
  "\t\texpo ++;\n"
  "\t}\n"
  "\n"
  "\tdouble  thrMin = thrMax / 10;\n"
  "\twhile(fmant < thrMin) {\n"
  "\t\tfmant *= 10;\n"
  "\t\texpo --;\n"
  "\t}\n"
  "\n"
  "\tmant = fmant + 0.5;\n"
  "\n"
  "\n"
  "\t// normalize\n"
  "\twhile (mant % 10 == 0  &&  expo < PG_NUMERIC_EXPONENT_MAX) {\n"
  "\t\tmant /= 10;\n"
  "\t\texpo ++;\n"
  "\t}\n"
  "\n"
  "\tif (PG_NUMERIC_EXPONENT_MAX < expo) {\n"
  "\t\t// Exponent is overflow.\n"
  "\t\tint expoDiff = expo - PG_NUMERIC_EXPONENT_MAX;\n"
  "\t\tint\t\ti;\n"
  "\t\tulong\tmag;\n"
  "\n"
  "\t\tif (PG_MAX_DIGITS <= expoDiff) {\n"
  "\t\t\t// magnify is overflow\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\tfor (i=0, mag=1; i < expoDiff; i++) {\n"
  "\t\t\tmag *= 10;\n"
  "\t\t}\n"
  "\n"
  "\t\tif ((mant * mag) / mag != mant) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\texpo -= expoDiff;\n"
  "\t\tmant *= mag;\n"
  "\t}\n"
  "\n"
  "\t// Error check\n"
  "\tif (expo < PG_NUMERIC_EXPONENT_MIN || PG_NUMERIC_EXPONENT_MAX < expo ||\n"
  "\t\t(mant & ~PG_NUMERIC_MANTISSA_MASK)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tv.isnull = false;\n"
  "\tv.value  = PG_NUMERIC_SET(expo, sign, mant);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "pgfn_int2_numeric(__private int *errcode, pg_int2_t arg)\n"
  "{\n"
  "\tpg_int8_t tmp = { arg.value, arg.isnull };\n"
  "\treturn integer_to_numeric(errcode, tmp, sizeof(arg.value));\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "pgfn_int4_numeric(__private int *errcode, pg_int4_t arg)\n"
  "{\n"
  "\tpg_int8_t tmp = { arg.value, arg.isnull };\n"
  "\treturn integer_to_numeric(errcode, tmp, sizeof(arg.value));\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "pgfn_int8_numeric(__private int *errcode, pg_int8_t arg)\n"
  "{\n"
  "\treturn integer_to_numeric(errcode, arg, sizeof(arg.value));\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "pgfn_float4_numeric(__private int *errcode, pg_float4_t arg)\n"
  "{\n"
  "\tpg_float8_t tmp = { (cl_double)arg.value, arg.isnull };\n"
  "\treturn float_to_numeric(errcode, tmp, FLT_DIG);\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "pgfn_float8_numeric(__private int *errcode, pg_float8_t arg)\n"
  "{\n"
  "\treturn float_to_numeric(errcode, arg, DBL_DIG);\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "/*\n"
  " * Numeric operator functions\n"
  " * ----------------------------------------------------------------\n"
  " */\n"
  "static pg_numeric_t\n"
  "pgfn_numeric_uplus(__private int *errcode, pg_numeric_t arg)\n"
  "{\n"
  "\t/* return the value as-is */\n"
  "\treturn arg;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "pgfn_numeric_uminus(__private int *errcode, pg_numeric_t arg)\n"
  "{\n"
  "\t/* reverse the sign bit */\n"
  "\targ.value ^= PG_NUMERIC_SIGN_MASK;\n"
  "\treturn arg;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "pgfn_numeric_abs(__private int *errcode, pg_numeric_t arg)\n"
  "{\n"
  "\t/* clear the sign bit */\n"
  "\targ.value &= ~PG_NUMERIC_SIGN_MASK;\n"
  "\treturn arg;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "pgfn_numeric_add(__private int *errcode,\n"
  "\t\t\t\t pg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_numeric_t\tv;\n"
  "\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tint\t\t\texpo1 = PG_NUMERIC_EXPONENT(arg1.value);\n"
  "\tint\t\t\tsign1 = PG_NUMERIC_SIGN(arg1.value);\n"
  "\tcl_ulong\tmant1 = PG_NUMERIC_MANTISSA(arg1.value);\n"
  "\n"
  "\tint\t\t\texpo2 = PG_NUMERIC_EXPONENT(arg2.value);\n"
  "\tint\t\t\tsign2 = PG_NUMERIC_SIGN(arg2.value);\n"
  "\tcl_ulong\tmant2 = PG_NUMERIC_MANTISSA(arg2.value);\n"
  "\n"
  "\t// Change the number of digits\n"
  "\tif (expo1 != expo2) {\n"
  "\t\tint \t expoDiff = abs(expo1 - expo2);\n"
  "\t\tcl_ulong value\t  = (expo1 < expo2) ? (mant2) : (mant1);\n"
  "\t\tulong    mag;\n"
  "\t\tint      i;\n"
  "\n"
  "\t\tif (PG_MAX_DIGITS <= expoDiff) {\n"
  "\t\t\t// magnify is overflow\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\tmag = 1;\n"
  "\t\tfor (i=0; i < expoDiff; i++) {\n"
  "\t\t\tmag *= 10;\n"
  "\t\t}\n"
  "\n"
  "\t\t// Overflow check\n"
  "\t\tif ((value * mag) / mag != value) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\tif (expo1 < expo2) {\n"
  "\t\t\tmant2 = value * mag;\n"
  "\t\t\texpo2 = expo1;\n"
  "\t\t} else {\n"
  "\t\t\tmant1 = value * mag;\n"
  "\t\t\texpo1 = expo2;\n"
  "\t\t}\n"
  "\t}\n"
  "\n"
  "\t// Add mantissa \n"
  "\tif (sign1 != sign2) {\n"
  "\t\tif (mant1 < mant2) {\n"
  "\t\t\tsign1 = sign2;\n"
  "\t\t\tmant1 = mant2 - mant1;\n"
  "\t\t} else {\n"
  "\t\t\tmant1 -= mant2;\n"
  "\t\t}\n"
  "\t} else {\n"
  "\t\tif ((mant1 + mant2) < mant1) {\n"
  "\t\t\t// Overflow\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\t\tmant1 += mant2;\n"
  "\t}\n"
  "\n"
  "\t// Set 0 if mantissa is 0\n"
  "\tif(mant1 == 0UL) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\t// Normalize\n"
  "\twhile(mant1 % 10 == 0  &&  expo1 < PG_NUMERIC_EXPONENT_MAX) {\n"
  "\t\tmant1 /= 10;\n"
  "\t\texpo1 ++;\n"
  "\t}\n"
  "\n"
  "\t// Error check\n"
  "\tif (expo1 < PG_NUMERIC_EXPONENT_MIN || PG_NUMERIC_EXPONENT_MAX < expo1 ||\n"
  "\t\t(mant1 & ~PG_NUMERIC_MANTISSA_MASK)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\t// Set\n"
  "\tv.isnull = false;\n"
  "\tv.value  = PG_NUMERIC_SET(expo1, sign1, mant1);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "pgfn_numeric_sub(__private int *errcode,\n"
  "\t\t\t\t pg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_numeric_t arg = pgfn_numeric_uminus(errcode, arg2);\n"
  "\t\n"
  "\treturn pgfn_numeric_add(errcode, arg1, arg);\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_numeric_t\n"
  "pgfn_numeric_mul(__private int *errcode,\n"
  "\t\t\t\t pg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_numeric_t\tv;\n"
  "\n"
  "\tif (arg1.isnull || arg2.isnull) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\tint\t\t\texpo1 = PG_NUMERIC_EXPONENT(arg1.value);\n"
  "\tint\t\t\tsign1 = PG_NUMERIC_SIGN(arg1.value);\n"
  "\tcl_ulong\tmant1 = PG_NUMERIC_MANTISSA(arg1.value);\n"
  "\n"
  "\tint\t\t\texpo2 = PG_NUMERIC_EXPONENT(arg2.value);\n"
  "\tint\t\t\tsign2 = PG_NUMERIC_SIGN(arg2.value);\n"
  "\tcl_ulong\tmant2 = PG_NUMERIC_MANTISSA(arg2.value);\n"
  "\n"
  "\t// Set 0, if mantissa is 0.\n"
  "\tif (mant1 == 0UL || mant2 == 0UL) {\n"
  "\t\tv.isnull = false;\n"
  "\t\tv.value  = PG_NUMERIC_SET(0, 0, 0);\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\t// Calculate exponential\n"
  "\texpo1 += expo2;\n"
  "\n"
  "\t// Calculate sign\n"
  "\tsign1 ^= sign2;\n"
  " \n"
  "\t// Calculate mantissa\n"
  "\tif ((mant1 * mant2) / mant2 != mant1) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\tmant1 *= mant2;\n"
  "\n"
  "\t// Normalize\n"
  "\twhile (mant1 % 10 == 0  &&  expo1 < PG_NUMERIC_EXPONENT_MAX) {\n"
  "\t\tmant1 /= 10;\n"
  "\t\texpo1 ++;\n"
  "\t}\n"
  "\n"
  "\tif (PG_NUMERIC_EXPONENT_MAX < expo1) {\n"
  "\t\t// Exponent is overflow.\n"
  "\t\tint expoDiff = expo1 - PG_NUMERIC_EXPONENT_MAX;\n"
  "\n"
  "\t\tulong mag;\n"
  "\t\tint\ti;\n"
  "\n"
  "\t\tif (PG_MAX_DIGITS <= expoDiff) {\n"
  "\t\t\t// magnify is overflow\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\tfor (i=0, mag=1; i < expoDiff; i++) {\n"
  "\t\t\tmag *= 10;\n"
  "\t\t}\n"
  "\n"
  "\t\tif ((mant1 * mag) / mag != mant1) {\n"
  "\t\t\tv.isnull = true;\n"
  "\t\t\tv.value  = 0;\n"
  "\t\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\t\treturn v;\n"
  "\t\t}\n"
  "\n"
  "\t\texpo1 -= expoDiff;\n"
  "\t\tmant1 *= mag;\n"
  "\t}\n"
  "\n"
  "\t// Error check\n"
  "\tif (expo1 < PG_NUMERIC_EXPONENT_MIN || PG_NUMERIC_EXPONENT_MAX < expo1 ||\n"
  "\t\t(mant1 & ~PG_NUMERIC_MANTISSA_MASK)) {\n"
  "\t\tv.isnull = true;\n"
  "\t\tv.value  = 0;\n"
  "\t\t*errcode = StromError_CpuReCheck;\n"
  "\t\treturn v;\n"
  "\t}\n"
  "\n"
  "\t// set\n"
  "\tv.isnull = false;\n"
  "\tv.value  = PG_NUMERIC_SET(expo1, sign1, mant1);\n"
  "\n"
  "\treturn v;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "/*\n"
  " * Numeric comparison functions\n"
  " * ----------------------------------------------------------------\n"
  " */\n"
  "static int\n"
  "numeric_cmp(__private cl_int *errcode, pg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tint\t\t\texpo1 = PG_NUMERIC_EXPONENT(arg1.value);\n"
  "\tint\t\t\tsign1 = PG_NUMERIC_SIGN(arg1.value);\n"
  "\tcl_ulong\tmant1 = PG_NUMERIC_MANTISSA(arg1.value);\n"
  "\n"
  "\tint\t\t\texpo2 = PG_NUMERIC_EXPONENT(arg2.value);\n"
  "\tint\t\t\tsign2 = PG_NUMERIC_SIGN(arg2.value);\n"
  "\tcl_ulong\tmant2 = PG_NUMERIC_MANTISSA(arg2.value);\n"
  "\n"
  "\n"
  "\t// Ignore exponential and sign, if both mantissa is 0.\n"
  "\tif(mant1 == 0  &&  mant2 == 0) {\n"
  "\t\treturn 0;\n"
  "\t}\n"
  "\n"
  "\t// Compair flag, If sign flag is different.\n"
  "\tif(sign1 != sign2) {\n"
  "\t\treturn sign2 - sign1;\n"
  "\t}\n"
  "\n"
  "\t// Compair the exponential/matissa.\n"
  "\tint\t\t expoDiff = min(PG_MAX_DIGITS, (int)(abs(expo1 - expo2)));\n"
  "\n"
  "\tcl_ulong mantL, mantR;\n"
  "\tulong\t mag;\n"
  "\tint\t\t i, ret;\n"
  "\n"
  "\tif (expo1 < expo2) {\n"
  "\t\tmantL = mant1;\n"
  "\t\tmantR = mant2;\t// arg2's exponential is large.\n"
  "\t} else {\n"
  "\t\tmantL = mant2;\n"
  "\t\tmantR = mant1;\t// arg1's exponential is large.\n"
  "\t}\n"
  "\n"
  "\tfor (i=0, mag=1; i < expoDiff; i++) {\n"
  "\t\tmag *= 10;\n"
  "\t}\n"
  "\n"
  "\tif ((mantR * mag) / mag != mantR  ||  mantL < mantR * mag) {\n"
  "\t\t// mantR * mag is overflow, or larger than mantL\n"
  "\t\tret = 1;\n"
  "\t} else if(mantL == mantR * mag) {\n"
  "\t\tret = 0;\n"
  "\t} else {\n"
  "\t\tret = -1;\n"
  "\t}\n"
  "\n"
  "\tif(expo1 < expo2) {\n"
  "\t\tret *= -1;\n"
  "\t}\n"
  "\n"
  "\tif(sign1 != 0) {\n"
  "\t\tret *= -1;\n"
  "\t}\n"
  "\n"
  "\treturn ret;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_bool_t\n"
  "pgfn_numeric_eq(__private cl_int *errcode,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(errcode, arg1, arg2) == 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_bool_t\n"
  "pgfn_numeric_ne(__private cl_int *errcode,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(errcode, arg1, arg2) != 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_bool_t\n"
  "pgfn_numeric_lt(__private cl_int *errcode,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(errcode, arg1, arg2) < 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_bool_t\n"
  "pgfn_numeric_le(__private cl_int *errcode,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(errcode, arg1, arg2) <= 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_bool_t\n"
  "pgfn_numeric_gt(__private cl_int *errcode,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(errcode, arg1, arg2) > 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_bool_t\n"
  "pgfn_numeric_ge(__private cl_int *errcode,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_bool_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = (numeric_cmp(errcode, arg1, arg2) >= 0);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "static pg_int4_t\n"
  "pgfn_numeric_cmp(__private cl_int *errcode,\n"
  "\t\t\t\tpg_numeric_t arg1, pg_numeric_t arg2)\n"
  "{\n"
  "\tpg_int4_t\tresult;\n"
  "\n"
  "\tif (arg1.isnull  ||  arg2.isnull) {\n"
  "\t\tresult.isnull = true;\n"
  "\t\tresult.value  = 0;\n"
  "\n"
  "\t} else {\n"
  "\t\tresult.isnull = false;\n"
  "\t\tresult.value = numeric_cmp(errcode, arg1, arg2);\n"
  "\t}\n"
  "\n"
  "\treturn result;\n"
  "}\n"
  "\n"
  "#endif /* OPENCL_DEVICE_CODE */\n"
  "#endif /* OPENCL_NUMERIC_H */\n"
;
