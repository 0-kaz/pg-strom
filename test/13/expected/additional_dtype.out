---
--- test cases for custom data type int1
---
SET pg_strom.regression_test_mode = on;
SET client_min_messages = error;
DROP SCHEMA IF EXISTS custom_dtype_temp CASCADE;
CREATE SCHEMA custom_dtype_temp;
RESET client_min_messages;
SET search_path = custom_dtype_temp,public;
---
--- int1
---
--- data type define
CREATE TABLE int1_table(
    id  smallint,
    num1    int1
);
-- range check
INSERT INTO int1_table values (0,0);
INSERT INTO int1_table values (1,-128);  -- lower limit
INSERT INTO int1_table values (2,127);   -- upper limit
INSERT INTO int1_table values (3,-129);  -- lower error
ERROR:  tinyint out of range
INSERT INTO int1_table values (4,128);   -- upper error
ERROR:  tinyint out of range
-- cast
CREATE TABLE various_dtypes(
    i1       int1,
    i2       int2,
    i4       int4,
    i8       int8,
    f2       float2,
    f4       float4,
    f8       float8,
    nm       numeric,
    ch       char(3),
    i1_1     int1
);
INSERT INTO various_dtypes VALUES (11,12,14,18,21.1,22.2,24.4,33.33,'123',3);
-- memo: sql generating two liner
-- declare -A d=(["i2"]="int2" ["i4"]="int4" [i8]="int8" ["f2"]="float2" ["f4"]="float4" ["f8"]="float8" ["nm"]="numeric" ["ch"]="char(3)");
-- echo "SELECT " ; for cn in ${!d[@]}; do echo "cast($cn AS int1) \"${cn}_i1\", cast(i1 AS ${d[$cn]}) \"i1_$cn\"," ; done | awk '{if (NR==eof)print $0; else print $0","}' ; echo "FROM various_dtypes;"
SELECT 
cast(f2 AS int1) "f2_i1", cast(i1 AS float2) "i1_f2",
cast(f4 AS int1) "f4_i1", cast(i1 AS float4) "i1_f4",
cast(f8 AS int1) "f8_i1", cast(i1 AS float8) "i1_f8",
cast(ch AS int1) "ch_i1", cast(i1 AS char(3)) "i1_ch",
cast(nm AS int1) "nm_i1", cast(i1 AS numeric) "i1_nm",
cast(i8 AS int1) "i8_i1", cast(i1 AS int8) "i1_i8",
cast(i2 AS int1) "i2_i1", cast(i1 AS int2) "i1_i2",
cast(i4 AS int1) "i4_i1", cast(i1 AS int4) "i1_i4"
FROM various_dtypes;
 f2_i1 | i1_f2 | f4_i1 | i1_f4 | f8_i1 | i1_f8 | ch_i1 | i1_ch | nm_i1 | i1_nm | i8_i1 | i1_i8 | i2_i1 | i1_i2 | i4_i1 | i1_i4 
-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------
 21    | 11    | 22    |    11 | 24    |    11 | 123   | 11    | 33    |    11 | 18    |    11 | 12    |    11 | 14    |    11
(1 row)

---- comarison
-- eq,ne,lt,le,gt,ge
-- int1,int2,int4,int8
-- declare -A cs=(["eq"]="=" ["ne"]="<>" ["lt"]="<" ["le"]="<=" ["gt"]=">" ["ge"]=">=");
-- declare -A it=(["eq"]="TRUE" ["ne"]="FALSE" ["lt"]="FALSE" ["le"]="TRUE" ["gt"]="FALSE" ["ge"]="TRUE");
-- echo "SELECT " ; for c in ${!cs[@]}; do echo "(i1 ${cs[$c]} i1) is ${it[$c]} as i1_${c}_i1" ; done | awk -F, 'NR==1{print $0}NR>1{print ","$0}' ; echo "FROM various_dtypes;"
SELECT 
(i1 = i1) is TRUE as i1_eq_i1
,(i1 >= i1) is TRUE as i1_ge_i1
,(i1 <> i1) is FALSE as i1_ne_i1
,(i1 > i1) is FALSE as i1_gt_i1
,(i1 <= i1) is TRUE as i1_le_i1
,(i1 < i1) is FALSE as i1_lt_i1
FROM various_dtypes;
 i1_eq_i1 | i1_ge_i1 | i1_ne_i1 | i1_gt_i1 | i1_le_i1 | i1_lt_i1 
----------+----------+----------+----------+----------+----------
 t        | t        | t        | t        | t        | t
(1 row)

-- unset d; declare -A d=(["i2"]="12" ["i4"]="14" ["i8"]="18");
-- echo "SELECT "; for c in ${!cs[@]}; do for cn in ${!d[@]}; do echo "(i1 ${cs[$c]} $cn) is $(test 11 -${c} ${d[$cn]} && echo TRUE || echo FALSE) \"11_${c}_${d[$cn]}\" , ($cn ${cs[$c]} i1) is $(test ${d[$cn]} -${c} 11 && echo TRUE || echo FALSE) \"${d[$cn]}_${c}_11\"" ; done ; done | awk 'NR==1{print $0} NR>1{print ","$0}' ; echo "FROM various_dtypes;"
SELECT 
(i1 = i8) is FALSE "11_eq_18" , (i8 = i1) is FALSE "18_eq_11"
,(i1 = i2) is FALSE "11_eq_12" , (i2 = i1) is FALSE "12_eq_11"
,(i1 = i4) is FALSE "11_eq_14" , (i4 = i1) is FALSE "14_eq_11"
,(i1 >= i8) is FALSE "11_ge_18" , (i8 >= i1) is TRUE "18_ge_11"
,(i1 >= i2) is FALSE "11_ge_12" , (i2 >= i1) is TRUE "12_ge_11"
,(i1 >= i4) is FALSE "11_ge_14" , (i4 >= i1) is TRUE "14_ge_11"
,(i1 <> i8) is TRUE "11_ne_18" , (i8 <> i1) is TRUE "18_ne_11"
,(i1 <> i2) is TRUE "11_ne_12" , (i2 <> i1) is TRUE "12_ne_11"
,(i1 <> i4) is TRUE "11_ne_14" , (i4 <> i1) is TRUE "14_ne_11"
,(i1 > i8) is FALSE "11_gt_18" , (i8 > i1) is TRUE "18_gt_11"
,(i1 > i2) is FALSE "11_gt_12" , (i2 > i1) is TRUE "12_gt_11"
,(i1 > i4) is FALSE "11_gt_14" , (i4 > i1) is TRUE "14_gt_11"
,(i1 <= i8) is TRUE "11_le_18" , (i8 <= i1) is FALSE "18_le_11"
,(i1 <= i2) is TRUE "11_le_12" , (i2 <= i1) is FALSE "12_le_11"
,(i1 <= i4) is TRUE "11_le_14" , (i4 <= i1) is FALSE "14_le_11"
,(i1 < i8) is TRUE "11_lt_18" , (i8 < i1) is FALSE "18_lt_11"
,(i1 < i2) is TRUE "11_lt_12" , (i2 < i1) is FALSE "12_lt_11"
,(i1 < i4) is TRUE "11_lt_14" , (i4 < i1) is FALSE "14_lt_11"
FROM various_dtypes;
 11_eq_18 | 18_eq_11 | 11_eq_12 | 12_eq_11 | 11_eq_14 | 14_eq_11 | 11_ge_18 | 18_ge_11 | 11_ge_12 | 12_ge_11 | 11_ge_14 | 14_ge_11 | 11_ne_18 | 18_ne_11 | 11_ne_12 | 12_ne_11 | 11_ne_14 | 14_ne_11 | 11_gt_18 | 18_gt_11 | 11_gt_12 | 12_gt_11 | 11_gt_14 | 14_gt_11 | 11_le_18 | 18_le_11 | 11_le_12 | 12_le_11 | 11_le_14 | 14_le_11 | 11_lt_18 | 18_lt_11 | 11_lt_12 | 12_lt_11 | 11_lt_14 | 14_lt_11 
----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------
 t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t        | t
(1 row)

---- unary operators
--- +, - , @
SELECT +i1>0 as u1,-i1<0 as u2,@(-i1) >0 as u3 FROM various_dtypes;
 u1 | u2 | u3 
----+----+----
 t  | t  | t
(1 row)

---- arthmetic operators
--- +,-,*,/,%
-- int1 and int1
-- declare -A v=(["i1_1"]=3)
-- declare -A ops=(["plus"]="+" ["minus"]="-" ["mul"]="*" ["div"]="/" ["mod"]="%")
-- echo "SELECT "; for i in ${!v[@]};do for o in "${!ops[@]}"; do val=$(("11 ${ops[$o]} ${v[$i]}"))  ; echo "(i1 ${ops[$o]} ${i}) = ${val} as \"i1_${o}_${i}\"" ; done ; done | awk 'NR==1{print $0}NR>1{print ","$0}' && echo "FROM various_dtypes;"
SELECT 
(i1 % i1_1) = 2 as "i1_mod_i1_1"
,(i1 / i1_1) = 3 as "i1_div_i1_1"
,(i1 * i1_1) = 33 as "i1_mul_i1_1"
,(i1 + i1_1) = 14 as "i1_plus_i1_1"
,(i1 - i1_1) = 8 as "i1_minus_i1_1"
FROM various_dtypes;
 i1_mod_i1_1 | i1_div_i1_1 | i1_mul_i1_1 | i1_plus_i1_1 | i1_minus_i1_1 
-------------+-------------+-------------+--------------+---------------
 t           | t           | t           | t            | t
(1 row)

-- int1 and (int2,int4,int8)
-- % is not supported here.
-- unset ops["mod"]
-- echo "SELECT "; for i in ${!v[@]};do for o in "${!ops[@]}"; do val=$(("${v[$i]} ${ops[$o]} 3"))  ; echo "(${i} ${ops[$o]} i1_1) = ${val} as \"i1_${o}_${i}\" -- ${v[$i]} ${ops[$o]} 3" ; done ; done | awk 'NR==1{print $0}NR>1{print ","$0}' && echo "FROM various_dtypes;"
SELECT 
(i8 / i1_1) = 6 as "i1_div_i8" -- 18 / 3
,(i8 * i1_1) = 54 as "i1_mul_i8" -- 18 * 3
,(i8 + i1_1) = 21 as "i1_plus_i8" -- 18 + 3
,(i8 - i1_1) = 15 as "i1_minus_i8" -- 18 - 3
,(i2 / i1_1) = 4 as "i1_div_i2" -- 12 / 3
,(i2 * i1_1) = 36 as "i1_mul_i2" -- 12 * 3
,(i2 + i1_1) = 15 as "i1_plus_i2" -- 12 + 3
,(i2 - i1_1) = 9 as "i1_minus_i2" -- 12 - 3
,(i4 / i1_1) = 4 as "i1_div_i4" -- 14 / 3
,(i4 * i1_1) = 42 as "i1_mul_i4" -- 14 * 3
,(i4 + i1_1) = 17 as "i1_plus_i4" -- 14 + 3
,(i4 - i1_1) = 11 as "i1_minus_i4" -- 14 - 3
FROM various_dtypes;
 i1_div_i8 | i1_mul_i8 | i1_plus_i8 | i1_minus_i8 | i1_div_i2 | i1_mul_i2 | i1_plus_i2 | i1_minus_i2 | i1_div_i4 | i1_mul_i4 | i1_plus_i4 | i1_minus_i4 
-----------+-----------+------------+-------------+-----------+-----------+------------+-------------+-----------+-----------+------------+-------------
 t         | t         | t          | t           | t         | t         | t          | t           | t         | t         | t          | t
(1 row)

---- bit operations
---- &,|,#,~,<<,>>
-- unset v;declare -A v=( ["i1_1"]=3 )
-- declare -A pbo=(["and"]="&" ["or"]="|" ["xor"]="#" ["lshift"]="<<" ["rshigt"]=">>")  # for postgres
-- declare -A bbo=(["and"]="&" ["or"]="|" ["xor"]="^" ["lshift"]="<<" ["rshigt"]=">>")  # for bash
-- echo "SELECT "; for i in ${!v[@]};do for o in "${!pbo[@]}"; do val=$(("11 ${bbo[$o]} ${v[$i]}"))  ; echo "(i1 ${pbo[$o]} ${i}) = ${val} as \"i1_${o}_${i}\" -- 11 ${pbo[$o]} ${v[$i]}" ; done ; done | awk 'NR==1{print $0}NR>1{print ","$0}' && echo "FROM various_dtypes;"
-- unset pbo; declare -A pbo=(["not"]="~")  # for postgres
-- unset bbo; declare -A bbo=(["not"]="~")  # for bash
-- echo "SELECT "; for i in ${!v[@]};do for o in "${!pbo[@]}"; do val=$(("${bbo[$o]}${v[${i}]}"))  ; echo "(${pbo[$o]} ${i}) = ${val} as \"${o}_${i}\" -- ${pbo[$o]}_${v[$i]}" ; done ; done | awk 'NR==1{print $0}NR>1{print ","$0}' && echo "FROM various_dtypes;"
-- TODO: FIX NOT operator position!
-- SELECT 
-- (~ i1_1) = -4 as "not_i1_1" -- ~_3
--FROM various_dtypes;
---- misc functions
-- money
---- aggregate function
-- sum,max,min,avg(larger,smaller)
-- variance,var_samp,var_pop,stddev, stddevv_samp,stddev_pop
---- index support
-- cmp,hash
-- cleanup temporary resource
SET client_min_messages = error;
DROP SCHEMA custom_dtype_temp CASCADE;
