--#
--#       Gpu HashJoin Explain TestCases. 
--#
set gpu_setup_cost=0;
set enable_gpupreagg to off;
set enable_gpusort to off;
set random_page_cost=1000000;   --# force off index_scan.
set client_min_messages to warning;
set pg_strom.enabled=off;
---
--- BULKLOAD ON
---
--smallint
explain (verbose, costs off, timing off) select a.id,case when a.smlint_x = b.smlint_x then a.smlint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.smlint_x=b.smlint_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END
         Join Filter: ((strom_test.smlint_x = strom_test_1.smlint_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(12 rows)

--integer
explain (verbose, costs off, timing off) select a.id,case when a.integer_x = b.integer_x then a.integer_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.integer_x=b.integer_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END
         Join Filter: ((strom_test.integer_x = strom_test_1.integer_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(12 rows)

--bigint
explain (verbose, costs off, timing off) select a.id,case when a.bigint_x = b.bigint_x then a.bigint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.bigint_x=b.bigint_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE 0::bigint END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE 0::bigint END
         Join Filter: ((strom_test.bigint_x = strom_test_1.bigint_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(12 rows)

--real
explain (verbose, costs off, timing off) select a.id,case when a.real_x = b.real_x then a.real_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.real_x=b.real_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE 0::real END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE 0::real END
         Join Filter: ((strom_test.real_x = strom_test_1.real_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(12 rows)

--float
explain (verbose, costs off, timing off) select a.id,case when a.float_x = b.float_x then a.float_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.float_x=b.float_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE 0::double precision END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE 0::double precision END
         Join Filter: ((strom_test.float_x = strom_test_1.float_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(12 rows)

--numeric
explain (verbose, costs off, timing off) select a.id,case when a.nume_x = b.nume_x then a.nume_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.nume_x=b.nume_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE 0::numeric END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE 0::numeric END
         Join Filter: ((strom_test.nume_x = strom_test_1.nume_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(12 rows)

--small serial
explain (verbose, costs off, timing off) select a.id,case when a.smlsrl_x = b.smlsrl_x then a.smlsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.smlsrl_x=b.smlsrl_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END
         Join Filter: ((strom_test.smlsrl_x = strom_test_1.smlsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(12 rows)

--serial
explain (verbose, costs off, timing off) select a.id,case when a.serial_x = b.serial_x then a.serial_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.serial_x=b.serial_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END
         Join Filter: ((strom_test.serial_x = strom_test_1.serial_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(12 rows)

--big serial
explain (verbose, costs off, timing off) select a.id,case when a.bigsrl_x = b.bigsrl_x then a.bigsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.bigsrl_x=b.bigsrl_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE 0::bigint END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE 0::bigint END
         Join Filter: ((strom_test.bigsrl_x = strom_test_1.bigsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
(12 rows)

---
--- BULKLOAD OFF
---
--smallint
explain (verbose, costs off, timing off) select a.id,case when a.smlint_x = b.smlint_x then a.smlint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.smlint_x=b.smlint_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END
         Join Filter: ((strom_test.smlint_x = strom_test_1.smlint_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(12 rows)

--integer
explain (verbose, costs off, timing off) select a.id,case when a.integer_x = b.integer_x then a.integer_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.integer_x=b.integer_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END
         Join Filter: ((strom_test.integer_x = strom_test_1.integer_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(12 rows)

--bigint
explain (verbose, costs off, timing off) select a.id,case when a.bigint_x = b.bigint_x then a.bigint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.bigint_x=b.bigint_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE 0::bigint END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE 0::bigint END
         Join Filter: ((strom_test.bigint_x = strom_test_1.bigint_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(12 rows)

--real
explain (verbose, costs off, timing off) select a.id,case when a.real_x = b.real_x then a.real_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.real_x=b.real_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE 0::real END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE 0::real END
         Join Filter: ((strom_test.real_x = strom_test_1.real_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(12 rows)

--float
explain (verbose, costs off, timing off) select a.id,case when a.float_x = b.float_x then a.float_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.float_x=b.float_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE 0::double precision END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE 0::double precision END
         Join Filter: ((strom_test.float_x = strom_test_1.float_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(12 rows)

--numeric
explain (verbose, costs off, timing off) select a.id,case when a.nume_x = b.nume_x then a.nume_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.nume_x=b.nume_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE 0::numeric END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE 0::numeric END
         Join Filter: ((strom_test.nume_x = strom_test_1.nume_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(12 rows)

--small serial
explain (verbose, costs off, timing off) select a.id,case when a.smlsrl_x = b.smlsrl_x then a.smlsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.smlsrl_x=b.smlsrl_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END
         Join Filter: ((strom_test.smlsrl_x = strom_test_1.smlsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(12 rows)

--serial
explain (verbose, costs off, timing off) select a.id,case when a.serial_x = b.serial_x then a.serial_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.serial_x=b.serial_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END
         Join Filter: ((strom_test.serial_x = strom_test_1.serial_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(12 rows)

--big serial
explain (verbose, costs off, timing off) select a.id,case when a.bigsrl_x = b.bigsrl_x then a.bigsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.bigsrl_x=b.bigsrl_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: strom_test.id, (CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE 0::bigint END)
   Sort Key: strom_test.id
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE 0::bigint END
         Join Filter: ((strom_test.bigsrl_x = strom_test_1.bigsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Seq Scan on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0) AND ((strom_test.id)::text !~~ ''::text))
         ->  Seq Scan on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0) AND ((strom_test_1.id)::text !~~ ''::text))
(12 rows)

set pg_strom.enabled=on;
---
--- BULKLOAD ON
---
--smallint
explain (verbose, costs off, timing off) select a.id,case when a.smlint_x = b.smlint_x then a.smlint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.smlint_x=b.smlint_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END
         Join Filter: ((strom_test.smlint_x = strom_test_1.smlint_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(15 rows)

--integer
explain (verbose, costs off, timing off) select a.id,case when a.integer_x = b.integer_x then a.integer_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.integer_x=b.integer_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END
         Join Filter: ((strom_test.integer_x = strom_test_1.integer_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(15 rows)

--bigint
explain (verbose, costs off, timing off) select a.id,case when a.bigint_x = b.bigint_x then a.bigint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.bigint_x=b.bigint_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE 0::bigint END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE 0::bigint END
         Join Filter: ((strom_test.bigint_x = strom_test_1.bigint_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(15 rows)

--real
explain (verbose, costs off, timing off) select a.id,case when a.real_x = b.real_x then a.real_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.real_x=b.real_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE 0::real END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE 0::real END
         Join Filter: ((strom_test.real_x = strom_test_1.real_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(15 rows)

--float
explain (verbose, costs off, timing off) select a.id,case when a.float_x = b.float_x then a.float_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.float_x=b.float_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE 0::double precision END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE 0::double precision END
         Join Filter: ((strom_test.float_x = strom_test_1.float_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(15 rows)

--numeric
explain (verbose, costs off, timing off) select a.id,case when a.nume_x = b.nume_x then a.nume_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.nume_x=b.nume_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE 0::numeric END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE 0::numeric END
         Join Filter: ((strom_test.nume_x = strom_test_1.nume_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(15 rows)

--small serial
explain (verbose, costs off, timing off) select a.id,case when a.smlsrl_x = b.smlsrl_x then a.smlsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.smlsrl_x=b.smlsrl_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END
         Join Filter: ((strom_test.smlsrl_x = strom_test_1.smlsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(15 rows)

--serial
explain (verbose, costs off, timing off) select a.id,case when a.serial_x = b.serial_x then a.serial_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.serial_x=b.serial_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END
         Join Filter: ((strom_test.serial_x = strom_test_1.serial_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(15 rows)

--big serial
explain (verbose, costs off, timing off) select a.id,case when a.bigsrl_x = b.bigsrl_x then a.bigsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 ) as b
 on a.bigsrl_x=b.bigsrl_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE 0::bigint END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE 0::bigint END
         Join Filter: ((strom_test.bigsrl_x = strom_test_1.bigsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(15 rows)

---
--- BULKLOAD OFF
---
--smallint
explain (verbose, costs off, timing off) select a.id,case when a.smlint_x = b.smlint_x then a.smlint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.smlint_x=b.smlint_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.smlint_x = strom_test_1.smlint_x) THEN (strom_test.smlint_x)::integer ELSE 0 END
         Join Filter: ((strom_test.smlint_x = strom_test_1.smlint_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(17 rows)

--integer
explain (verbose, costs off, timing off) select a.id,case when a.integer_x = b.integer_x then a.integer_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.integer_x=b.integer_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.integer_x = strom_test_1.integer_x) THEN strom_test.integer_x ELSE 0 END
         Join Filter: ((strom_test.integer_x = strom_test_1.integer_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(17 rows)

--bigint
explain (verbose, costs off, timing off) select a.id,case when a.bigint_x = b.bigint_x then a.bigint_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.bigint_x=b.bigint_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE 0::bigint END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.bigint_x = strom_test_1.bigint_x) THEN strom_test.bigint_x ELSE 0::bigint END
         Join Filter: ((strom_test.bigint_x = strom_test_1.bigint_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(17 rows)

--real
explain (verbose, costs off, timing off) select a.id,case when a.real_x = b.real_x then a.real_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.real_x=b.real_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE 0::real END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.real_x = strom_test_1.real_x) THEN strom_test.real_x ELSE 0::real END
         Join Filter: ((strom_test.real_x = strom_test_1.real_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(17 rows)

--float
explain (verbose, costs off, timing off) select a.id,case when a.float_x = b.float_x then a.float_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.float_x=b.float_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE 0::double precision END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.float_x = strom_test_1.float_x) THEN strom_test.float_x ELSE 0::double precision END
         Join Filter: ((strom_test.float_x = strom_test_1.float_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(17 rows)

--numeric
explain (verbose, costs off, timing off) select a.id,case when a.nume_x = b.nume_x then a.nume_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.nume_x=b.nume_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE 0::numeric END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.nume_x = strom_test_1.nume_x) THEN strom_test.nume_x ELSE 0::numeric END
         Join Filter: ((strom_test.nume_x = strom_test_1.nume_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(17 rows)

--small serial
explain (verbose, costs off, timing off) select a.id,case when a.smlsrl_x = b.smlsrl_x then a.smlsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.smlsrl_x=b.smlsrl_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.smlsrl_x = strom_test_1.smlsrl_x) THEN (strom_test.smlsrl_x)::integer ELSE 0 END
         Join Filter: ((strom_test.smlsrl_x = strom_test_1.smlsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(17 rows)

--serial
explain (verbose, costs off, timing off) select a.id,case when a.serial_x = b.serial_x then a.serial_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.serial_x=b.serial_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.serial_x = strom_test_1.serial_x) THEN strom_test.serial_x ELSE 0 END
         Join Filter: ((strom_test.serial_x = strom_test_1.serial_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(17 rows)

--big serial
explain (verbose, costs off, timing off) select a.id,case when a.bigsrl_x = b.bigsrl_x then a.bigsrl_x else 0 end from 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as a
 inner join 
(select * from strom_test where id between 20001 and 30000 and id%100=0 and id::text not like '' ) as b
 on a.bigsrl_x=b.bigsrl_x and a.id=b.id order by a.id;
                                                                                                                             QUERY PLAN                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (GpuSort)
   Output: strom_test.id, (CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE 0::bigint END)
   Sort Key: strom_test.id
   Features: likely-tuple-slot
   ->  Nested Loop
         Output: strom_test.id, CASE WHEN (strom_test.bigsrl_x = strom_test_1.bigsrl_x) THEN strom_test.bigsrl_x ELSE 0::bigint END
         Join Filter: ((strom_test.bigsrl_x = strom_test_1.bigsrl_x) AND (strom_test.id = strom_test_1.id))
         ->  Custom Scan (GpuScan) on public.strom_test
               Output: strom_test.id, strom_test.key, strom_test.smlint_x, strom_test.integer_x, strom_test.bigint_x, strom_test.real_x, strom_test.float_x, strom_test.nume_x, strom_test.smlsrl_x, strom_test.serial_x, strom_test.bigsrl_x
               Filter: ((strom_test.id)::text !~~ ''::text)
               Device Filter: ((strom_test.id >= 20001) AND (strom_test.id <= 30000) AND ((strom_test.id % 100) = 0))
               Features: likely-tuple-slot
         ->  Custom Scan (GpuScan) on public.strom_test strom_test_1
               Output: strom_test_1.id, strom_test_1.key, strom_test_1.smlint_x, strom_test_1.integer_x, strom_test_1.bigint_x, strom_test_1.real_x, strom_test_1.float_x, strom_test_1.nume_x, strom_test_1.smlsrl_x, strom_test_1.serial_x, strom_test_1.bigsrl_x
               Filter: ((strom_test_1.id)::text !~~ ''::text)
               Device Filter: ((strom_test_1.id >= 20001) AND (strom_test_1.id <= 30000) AND ((strom_test_1.id % 100) = 0))
               Features: likely-tuple-slot
(17 rows)

